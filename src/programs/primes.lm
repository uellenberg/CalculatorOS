folder "Primes" {
    stackfunction p_rimes() {
        stackvar output;
        m_alloc(1, &output);
        w_rite(output, 0, 0);

        stackvar pid;
        f_ork(&pid);

        if (pid < 0) {
            p_rint(string!("Fail")[1]);
            return;
        }

        if (pid == 0) {
            // Child process: find and store a prime.
            stackvar i;
            // * 2 + 1 ensures the number is odd.
            i = floor(random() * 100000000) * 2 + 1;

            while (!m_iller_rabin_test(i)) {
                i = i + 2;
            }

            w_rite(output, 0, i);
            return;
        }

        // Parent process: wait for child to finish and read the prime.
        while (true) {
            stackvar prime;
            r_ead(output, 0, &prime);

            if (prime != 0) {
                p_rint_int(prime);
                f_ree(output, 1);
                return;
            }

            p_rint(string!("...")[1]);
            s_leep(10);
        }
    }

    export function m_ul_mod(a, b, m) {
        if (b == 0) {
            0
        } else {
            const half = m_ul_mod(a, floor(b / 2), m);

            const res = mod(2*half, m);

            if (mod(b, 2) == 1) {
                mod(res + a, m)
            } else {
                res
            }
        }
    }

    export function p_ow_mod(b_ase, e_xp, m_od) {
        if (e_xp == 0) {
            1
        } else if (e_xp % 2 == 0) {
            const half = p_ow_mod(b_ase, floor(e_xp / 2), m_od);
            m_ul_mod(half, half, m_od)
        } else {
            const remainder = p_ow_mod(b_ase, e_xp - 1, m_od);
            m_ul_mod(b_ase, remainder, m_od)
        }
    }

    // Based on https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Testing_against_small_sets_of_bases

    export function f_ind_d_and_s(d, s) {
        if (d % 2 != 0) {
            (d, s)
        } else {
            f_ind_d_and_s(d / 2, s + 1)
        }
    }

    export function c_heck_witness(x, r, s, n) {
        if (r >= s) {
            false
        } else {
            const new_x = m_ul_mod(x, x, n);
            if (new_x == 1) {
                false
            } else if (new_x == n - 1) {
                true
            } else {
                c_heck_witness(new_x, r + 1, s, n)
            }
        }
    }

    // This set of witnesses is proven to be sufficient for a deterministic test
    // for all numbers up to 2^64.
    export const w_itnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];

    export function t_est_witnesses(i, n, d, s) {
        if (i >= w_itnesses.length) {
            true
        } else {
            const a = w_itnesses[i + 1];
            if (n == a) {
                true
            } else {
                 const x = p_ow_mod(a, d, n);
                 if (x != 1 && x != n - 1) {
                    if (!c_heck_witness(x, 1, s, n)) {
                        false
                    } else {
                        t_est_witnesses(i + 1, n, d, s)
                    }
                 } else {
                    t_est_witnesses(i + 1, n, d, s)
                 }
            }
        }
    }

    display hidden = true;
    export function m_iller_rabin_test(n) {
        if (n < 2) {
            false
        } else if (n == 2 || n == 3) {
            true
        } else if (n % 2 == 0) {
            false
        } else {
            const d_and_s = f_ind_d_and_s(n - 1, 0);
            const d = d_and_s.x;
            const s = d_and_s.y;

            t_est_witnesses(0, n, d, s)
        }
    }
}