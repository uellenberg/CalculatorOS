createBehavior!("write_test", {
    setDefaultDisplay!({ display folder = "Write Test"; });

    // The stack frame is slightly offset in order to create a piece of empty
    // space at w_rite_test_buffer[3].
    // This space is managed by us directly, not the runtime, so we can just access
    // it as *(3).
    setItemName!("w_rite_test_buffer");
    setVal!("write_test_buffer", { [stackid(r_un_test),4,0,-1,4] });
    setValAction!("write_test_buffer", {
        r_unstack(write_test_buffer)
    });

    setItemName!("b_yte_read_pos");
    setVal!("byte_read_pos", 0);

    // Clear if there's data and we're past the
    // correct range.
    setValAction!("write_test_buffer", {
        if(write_test_buffer[3] != 0 && getVal!("byte_read_pos") > (BYTES_PER_FLOAT - 1)) {
            let buffer = write_test_buffer;
            buffer[3] = 0;
            buffer
        } else {
            write_test_buffer
        }
    }, -10);
    setValAction!("byte_read_pos", {
        if(byte_read_pos > (BYTES_PER_FLOAT - 1)) {
            0
        } else {
            byte_read_pos
        }
    }, -9);


    setValAction!("byte_read_pos", {
        // Increment if there's data.
        if(getVal!("write_test_buffer")[3] != 0) {
            byte_read_pos + 1
        } else {
            byte_read_pos
        }
    }, 10);

    // Write to the display buffer if there's data and we're at a valid position.
    setValAction!("base.display.display_buffer", {
        if(getVal!("write_test_buffer")[3] != 0 && getVal!("byte_read_pos") > (BYTES_PER_FLOAT - 1)) {
            display_buffer
        } else {
            getByte(getVal!("write_test_buffer")[3], getVal!("byte_read_pos"))
        }
    }, 5);
});

display folder = "Write Test";
stackfunction r_un_test() {
    stackvar i;
    i = 0;
    const num_headers = floor(10000 / DISK_main_HEADER_SIZE);

    // Search for the first file record.
    while(i < num_headers && d_isk_main_header[1 + i * DISK_main_HEADER_SIZE] == 0) {
        i = i + 1;
    }

    stackvar j;
    j = 0;

    // Offset by the isActive byte, as well as
    // by Desmos' starting list index.
    const nameStart = 1 + i * DISK_main_HEADER_SIZE + 1;

    // Output each part of the file's name.
    while(d_isk_main_header[nameStart + j] != 0 && j < DISK_main_HEADER_NAME_SIZE) {
        // If there's an item in our output space that hasn't been
        // read yet, keep waiting until it has been.
        if(stack[3] == 0) {
            stack[3] = d_isk_main_header[nameStart + j];
            j = j + 1;
        }
    }

    // Now, read each block for data and output it.
    j = 0;

    // Offset by the isActive byte, as well as
    // by Desmos' starting list index.
    const blocksStart = 1 + i * DISK_main_HEADER_SIZE + 1 + DISK_main_HEADER_NAME_SIZE;
    while(d_isk_main_header[blocksStart + j] != 0 && j < DISK_main_HEADER_BLOCKS_SIZE) {
        const blockLocation = d_isk_main_header[blocksStart + j];

        // Each block is 2-bytes.
        stackvar byteIdx;
        byteIdx = 0;
        while(byteIdx < (BYTES_PER_FLOAT / 2) && getTwoByte(blockLocation, byteIdx) != 0) {
            // Find the starting index for the block (accounting for Desmos lists starting at 1).
            // Blocks start at 1 (so that the above check can work), but we need to correct
            // for this when doing our indexing.
            const blockIndex = 1 + DISK_main_BLOCK_SIZE * (getTwoByte(blockLocation, byteIdx) - 1);
            stackvar k;
            k = 0;
            while(d_isk_main_read(blockIndex + k) != 0 && k < DISK_main_BLOCK_SIZE) {
                // If there's an item in our output space that hasn't been
                // read yet, keep waiting until it has been.
                if(stack[3] == 0) {
                    stack[3] = d_isk_main_read(blockIndex + k);
                    k = k + 1;
                }
            }

            byteIdx = byteIdx + 1;
        }

        j = j + 1;
    }
}

inline function getByte(a, b) {
    const base = 256;
    const len = BYTES_PER_FLOAT;

    const pt1 = a/base^(len-b-1);
    const pt2 = a/base^(len-b);

    floor(pt1-floor(pt2)*base)
}

inline function getTwoByte(a, b) {
    const base = 256*256;
    const len = BYTES_PER_FLOAT / 2;

    const pt1 = a/base^(len-b-1);
    const pt2 = a/base^(len-b);

    floor(pt1-floor(pt2)*base)
}
