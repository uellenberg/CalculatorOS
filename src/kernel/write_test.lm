createBehavior!("write_test", {
    // The stack frame is slightly offset in order to create a piece of empty
    // space at w_rite_test_buffer[3].
    // This space is managed by us directly, not the runtime, so we can just access
    // it as *(3).
    setVal!("write_test_buffer", { [stackid(r_un_test),4,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0] });
    setValAction!("write_test_buffer", {
        r_unstack(write_test_buffer)
    });

    setVal!("byte_read_pos", 0);

    // Clear if there's data and we're past the
    // correct range.
    setValAction!("write_test_buffer", {
        if(write_test_buffer[3] != 0 && getVal!("byte_read_pos") > (BYTES_PER_FLOAT - 1)) {
            let buffer = write_test_buffer;
            buffer[3] = 0;
            buffer
        } else {
            write_test_buffer
        }
    }, -10);
    setValAction!("byte_read_pos", {
        if(byte_read_pos > (BYTES_PER_FLOAT - 1)) {
            0
        } else {
            byte_read_pos
        }
    }, -9);


    setValAction!("byte_read_pos", {
        // Increment if there's data.
        if(getVal!("write_test_buffer")[3] != 0) {
            byte_read_pos + 1
        } else {
            byte_read_pos
        }
    }, 10);

    // Write to the display buffer if there's data and we're at a valid position.
    setValAction!("base.display.display_buffer", {
        if(getVal!("write_test_buffer")[3] != 0 && getVal!("byte_read_pos") > (BYTES_PER_FLOAT - 1)) {
            display_buffer
        } else {
            getByte(getVal!("write_test_buffer")[3], getVal!("byte_read_pos"))
        }
    }, 5);
});

stackfunction r_un_test() {
    stackvar i;
    i = 0;
    const num_headers = floor(10000 / DISK_main_HEADER_SIZE);

    /*while(i < num_headers) {
        if (d_isk_main_header[i * DISK_main_HEADER_SIZE]) {
            // We found one.
            break;
        }

        i = i + 1;
    }*/
    while(i < num_headers && d_isk_main_header[i * DISK_main_HEADER_SIZE] == 0) {
        i = i + 1;
    }

    stackvar j;
    j = 0;

    const name_start = i * DISK_main_HEADER_SIZE + 1;

    while(d_isk_main_header[name_start + j] != 0) {
        // If there's an item in our output space that hasn't been
        // read yet, keep waiting until it has been.
        if(stack[3] == 0) {
            stack[3] = d_isk_main_header[name_start + j];
            j = j + 1;
        }
    }
}

inline function getByte(a, b) {
    const base = 256;
    const len = BYTES_PER_FLOAT;

    const pt1 = a/base^(len-b-1);
    const pt2 = a/base^(len-b);

    floor(pt1-floor(pt2)*base)
}
